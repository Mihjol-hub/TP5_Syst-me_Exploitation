#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <time.h>

#define PORT 65100 // Default port number
#define MAX_CLIENTS 1 // For now, only one client can connect to the server
#define BUFFER_SIZE 2 // Size of the messages exchanged (2 bytes)

// Define protocol messages
#define TOO_LOW -1
#define TOO_HIGH 1
#define WIN 0
#define LOSE 2

// Function to generate a random number between min and max
int generate_random_number(int min, int max) {
    return min + rand() % (max - min + 1);
}

int main(int argc, char *argv[]) {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    int interval_min = 1, interval_max = 100; // Range for the guessing game
    int secret_number;
    unsigned char buffer[BUFFER_SIZE];
    int attempts = 5; // Max number of attempts for the client

    // Seed the random number generator
    srand(time(NULL));

    // Step 1: Create the server socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Step 2: Setup server address structure
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY; // Listen on all interfaces
    server_addr.sin_port = htons(PORT);

    // Step 3: Bind the socket to the specified port
    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("Binding failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Step 4: Start listening for incoming connections
    if (listen(server_fd, MAX_CLIENTS) < 0) {
        perror("Listening failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server is listening on port %d...\n", PORT);

    // Step 5: Accept a new connection from a client
    client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_addr_len);
    if (client_fd < 0) {
        perror("Accepting connection failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Client connected with IP: %s\n", inet_ntoa(client_addr.sin_addr));

    // Generate a random secret number for the client to guess
    secret_number = generate_random_number(interval_min, interval_max);
    printf("The secret number is: %d\n", secret_number);

    // Send the initialization message (interval_min and interval_max) to the client
    buffer[0] = interval_min;
    buffer[1] = interval_max;
    write(client_fd, buffer, BUFFER_SIZE);

    // Step 6: Game loop - handle client guesses
    for (int i = 0; i < attempts; i++) {
        // Read client's guess
        int bytes_received = read(client_fd, buffer, BUFFER_SIZE);
        if (bytes_received < 0) {
            perror("Reading from client failed");
            break;
        }
        int client_guess = buffer[1]; // client's guess is in the second byte
        printf("Client guessed: %d\n", client_guess);

        // Check if the guess is correct, too high, or too low
        if (client_guess < secret_number) {
            buffer[0] = TOO_LOW;
        } else if (client_guess > secret_number) {
            buffer[0] = TOO_HIGH;
        } else {
            buffer[0] = WIN;
            write(client_fd, buffer, BUFFER_SIZE);
            printf("Client won the game\n");
            break;
        }

        // Send the result to the client
        buffer[1] = secret_number; // For debugging, send the actual number (as per instructions)
        write(client_fd, buffer, BUFFER_SIZE);

        // If it was the last attempt
        if (i == attempts - 1) {
            buffer[0] = LOSE;
            write(client_fd, buffer, BUFFER_SIZE);
            printf("Client lost the game\n");
        }
    }

    // Step 7: Close the connection
    close(client_fd);
    close(server_fd);
    printf("Server closed.\n");

    return 0;
}
